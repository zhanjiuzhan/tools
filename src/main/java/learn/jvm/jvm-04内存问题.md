# JVM - 内存问题
JVM 常见的内存问题有:  
+ 内存溢出: 内存不够用了。
+ 内存泄漏: 申请的空间已经不再用了，但是并没有被释放(占着茅坑不拉屎)。
## 1. 内存溢出   
OOM(Out Of Memory)，内存不够用了，要么内存太小，要么用完了。当 JVM 因为没用足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可以回收时，就会抛出 OutOfMemoryError 异常。即内存溢出。  
我们知道 jvm 中主要耗费内存的也就是方法区(现在叫元数据区)，堆，虚拟机栈(本地方法栈和虚拟机栈可以认为一种)。  
程序计数器是唯一不会抛异常的区域。  
### 1.1 虚拟机栈
虚拟机栈是线程私有的，每创建一个线程就会有一个虚拟机栈，每执行一个方法就会有一次进栈操作。所以当你无限创建线程时那么就会发生内存溢出即抛出OOM，每个栈都是有大小的，当你
不停的执行方法(无限递归)，即不停的进栈，那么栈本身空间不足就会SOF(StackOverflowError)。 

总结虚拟机栈会抛出的异常有: OOM，SOF  

那么怎么解决呢，你不要无限创建线程，不要无限递归(递归层次不要太深)那不就避免了，当然还有就是你可以调整栈的大小。  
通用的命令是， -Xss jdk1.5之后默认为1M，不管之前多少了，栈越大那么你开的线程数量就越少，栈越大那么栈的深度就越深(你可以多递归几次)。到底多大自己琢磨。

```java
public class JvmDemo2 {

    // 无限创建线程 兄弟就别试了 会越来越卡 直到卡死
    // 理论上出  OutOfMemoryError
    public static void demo1() {
        // 无限创建线程
        int i = 0;
        while(true) {
            new Thread(()->{
                try {
                    System.out.println("线程: " + Thread.currentThread().getName() );
                    Thread.sleep(60_000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, ("Thread_" + i++)).start();
        }
    }

    // 无限递归 java.lang.StackOverflowError
    public static void demo2() {
        demo2();
    }

    public static void main(String[] args) {
        demo2();
    }
}
```
### 1.2 堆
堆是最容易发生内存溢出的地方了，毕竟只要创建个对象，那么肯定在堆中进行空间申请，装不下就溢出。所以堆抛出的异常就是OOM。

通常，当堆(年轻代，年老代)满了，那就触发垃圾回收，怎么回收就是垃圾回收的机制了，通过垃圾回收把没用的就是垃圾给清理了，来一次次腾空间。直到内存泄漏，或者直接来个大家伙，或者就是清理不了了实在装不下了。那就OOM。

如何避免呢，可以通过调整堆的大小(堆的大小可是动态变化的，最大值<->最小值)，可以使用软引用(可以被回收)。  
> -Xms:初始堆大小(最小堆)。  
> -Xmx:最大堆大小。  
> -Xmn:年轻代大小(Sun官方推荐配置为整个堆的3/8)。  
> -Xms  和 -Xmx  设置成一致的值可以避免堆自动扩展。  

```java
// 创建个大对象 它就 OutOfMemoryError: Java heap space
String[][] str = new String[100000][100000];
```

### 1.3 元数据区
也就是原来的方法区了，常常存储类信息和常量，那么当类信息很多，或者常量超多它就OOM了，类信息怎么变多呢，动态代理了解一下，它就是创建类实现的代理，jsp解析是也会创建类。
通过程序创建的类变多那就内存不足了，常量通常是字符串。  

通常调整下大小，JDK8 使用-XX:MetaspaceSize和-XX:MaxMetaspaceSize 配置内存大小。  

### 1.4 直接内存
主要用于nio，作为缓存存储区，通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作，别名堆外内存。会抛出OOM。

## 2. 内存泄漏
内存泄漏过多就会造成jvm没有内存可用从而内存溢出。 c或c++的内存都是自己管理的，自己申请，自己释放。而java则是通过一个守护进程进行内存回收(GC)，内存泄漏，就是回收不了。
一般没用的内存都会被回收，那么现在为啥无法回收呢？
### 2.1 静态集合类
由于静态变量的生命周期和程序一致，当静态变量是集合时，且里面的成员是对象，那么它就一直持有集合内成员对象的引用，该集合或者集合内的对象已经不会在使用时，就是一种内存泄漏。  
集合的clear()方法会使得集合内元素置null，有利于集合内对象的快速回收。  
### 2.2 IO
我们都知道创建IO就需要用完关闭，不然这个IO会一直存在。常见的如数据库连接，socket，file相关。
### 2.3 变量的作用域大于其使用范围
一般来说都是推荐使用局部变量，类变量容易存在并发问题，成员变量生命周期和对象一致，它的描述最好是对象的属性，若作为大数据载体，这个数据可能只是一个或者两个方法使用后不再使用
，那么它还是一直存在。也是一种泄漏，对于spring 来说，bean经常是单例的，那么这个成员变量的生命周期可想而知。  
### 2.4 改变hash值
当对象被存储在hash这类数据结构中，由于它的寻找基本都是通过hash值来的，若该对象hashCode方法被重写，当对象存储之后，
对此参与计算hashCode的字段做了修改，那么已存储的对象将不会被找到。使用不当将造成泄漏。  
### 2.5 监听器
只是一味的添加监听器，当监听器不再使用时而未移除监听器时，会使得存在很多无用或者说过期的监听器在服务中未释放。  
### 2.6 引用未释放
A对象引用B对象，B对象引用C对象，所以A一直存活的话，那么B，C也将一直存活。这种连带的关系是需要主要的，内部类引用外部类，各种模块之间的引用等，当不再使用时及时置null。  


